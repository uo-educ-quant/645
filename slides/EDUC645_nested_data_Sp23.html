<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Nested Data</title>
    <meta charset="utf-8" />
    <script src="EDUC645_nested_data_Sp23_files/header-attrs-2.21/header-attrs.js"></script>
    <link href="EDUC645_nested_data_Sp23_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="EDUC645_nested_data_Sp23_files/remark-css-0.0.1/uo.css" rel="stylesheet" />
    <link href="EDUC645_nested_data_Sp23_files/remark-css-0.0.1/ki-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="my_custom.css" type="text/css" />
    <link rel="stylesheet" href="xaringanthemer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Nested Data
]
.subtitle[
## EDUC 645 (Spring 2023)
]

---





# What is Nested Data?


--
Nesting occurs when variability in our outcome occurs at multiple levels.


--
A common example we've already discussed is student outcomes: If Oregon were interested in looking at factors that influence students' academic performance, performance is expected to differ from student to student. Can performance vary at other levels?


--
- Performance could also vary from classroom to classroom (on average) and from school to school (on average). If the federal government were interested in this question, performance may also vary from state to state.


--
What are other examples of nesting you can think of?


--
Another form of nesting occurs in longitudinal studies, where the outcome is assessed multiple times for each participant. 


---
# What is Nested Data?

One way of thinking of nesting is as a form of &lt;span style = "color:green"&gt; clustering&lt;/span&gt;: There are clusters of observations in our data that share something in common. 


--
- Observations share the same context (e.g., the same classroom or school, when there are many classrooms or schools in our data) or could be clustered within each person in our dataset (multiple observations from the same person). 


--
Clustered observations are dependent, meaning they are more similar than they would be if they were unclustered (independent) observations.


--
In the academic performance example, what do you think happens if we don't account for variability in performance at the classroom and school levels? And what about the longitudinal study example, where we have dependent observations within each person?


--
- We get biased estimates of effects and precision.



---
# Analyzing Nested Data

--
In addition to more accurate estimates when we model nested or clustered data appropriately, we might be interested in different relationships at each level:


--
- Student level: Do students who are not routinely bullied have better performance than students who are routinely bullied?


--
- Classroom level: Does the presence of a teaching assistance result in better student performance, compared with classrooms that don't have a teaching assistant?


--
- School level: Do schools with a sufficient number of academic counselors report better student performance than schools with inadequate academic counseling?


--
With a model for nested data - generally called a multilevel model (MLM) or hierarchical linear model (HLM) - we can account for variability at multiple levels *and* test hypotheses at one or more levels using a single model. 


---
# Aggregation Bias

A final concern with nested data is that when we ignore nesting, we risk &lt;span style = "color:green"&gt; aggregation bias&lt;/span&gt;. 


--
Imagine we were studying the school-level question on the previous slide, Do schools with a sufficient number of academic counselors report better student performance than schools with inadequate academic counseling?


--
- In this example, school-level data was the mean student performance level for each school, and classroom-level data was the mean student performance level for each classroom. The higher level data are &lt;span style = "color:green"&gt; aggregate &lt;/span&gt;data, in the sense that means are aggregates of more granular data. 


--
If we modeled the relationship between two variables - whether or not the school had a sufficient number of academic counselors (IV) and mean student performance for each school (DV) - we might find that having adequate academic counseling was associated with greater average student performance. 


--
- Would this approach give us enough insight to conclude that policy-makers should provide more resources for academic counseling?


--
It might, but what if this relationship was different in each classroom? 





---
# Aggregation Bias

Maybe there was little or no relationship in small classrooms and a stronger relationship in larger classrooms. What's a plausible reason why this could be the case?


--
- Perhaps in small classrooms, teachers can give more attention to students, while in larger classrooms, students are not getting adequate support. 


--
- So, academic counseling makes more of a difference in the larger classrooms, because it is making up for support the teacher is not able to provide. In the smaller classrooms, the students don't need more support and are already high performing without academic counseling. 


--
Aggregation bias would occur if we concluded from our model that adequate academic counseling improves average student performance at the school level, when the relationship is actually more complex and depends on lower-level factors like class size (or presence of teaching assistants, etc). 


--
- If a policy-maker concluded from our school-level findings that the solution was for schools to have more funding for academic counseling, that might be wasting resources if more students would benefit from addressing the underlying, classroom-level issue (i.e., reducing class size by increasing funding to hire more teachers, have more classroom space, etc).


---
# Analyzing Nested Data

Several methods can be used to account for nesting or clustering of data so that we get more accurate estimates of associations (or effects) and error/significance. Some methods also allow for investigating relationships at multiple levels.


--
&lt;span style = "color:green"&gt; Adjusting standard errors: &lt;/span&gt; The most straightforward approach is to adjust the model standard errors for clustering. This is based on the idea that a naive model (where the clusters are ignored) would consider every observation independent, in which case there would appear to be more information in the data than there really is (resulting in artificially narrow confidence intervals). 


--
&lt;span style = "color:green"&gt; Subgroup-level analyses: &lt;/span&gt; With large enough sample sizes and appropriate adjustment for multiple comparisons, we could carry out our analyses within each subgroup or cluster.


--
&lt;span style = "color:green"&gt; Multilevel (or mixed-effects) models: &lt;/span&gt; The most common analytic approach for nested data, which can address dependency among observations and can be used to examine the relationships between the outcome and (different) predictors at each level. 


--
&lt;span style = "color:green"&gt; Repeated-measures models: &lt;/span&gt; With longitudinal data, there are several approaches that can be used to account for repeated observations from the same participant (e.g., growth curve modeling).


---
# Example

The Stanford Education Data Archive (SEDA) was launched in 2016 to provide nationally comparable, publicly available test score data for U.S. public school districts. 


--
SEDA allows researchers to study relationships between educational conditions, contexts, and outcomes (e.g., student math achievement) at the district level across the nation.


--
We'll look at district-level data for 103 Oregon school districts from the 2017-18 academic year. 

- Each district has 4 observations (rows), one for each grade from 3-6.

- Observations with missing values on any of the key variables were deleted for simplification.


---
# View the data 


```r
head(seda, n = 5) %&gt;% print_md()
```



|district             |  grade | achievement| gap_gender| percent_ell| percent_sped| percent_frl|
|:--------------------|:-------|-----------:|----------:|-----------:|------------:|-----------:|
|VALE SD 84           |Grade 3 |        2.54|       0.97|        0.05|         0.13|        0.62|
|VALE SD 84           |Grade 4 |        3.09|      -0.79|        0.05|         0.13|        0.62|
|VALE SD 84           |Grade 5 |        4.57|       0.84|        0.05|         0.13|        0.62|
|VALE SD 84           |Grade 6 |        6.03|       0.86|        0.05|         0.13|        0.62|
|YAMHILL CARLTON SD 1 |Grade 3 |        3.15|      -1.09|        0.01|         0.14|        0.43|


--
.small[Notice the 4 observations for each grade in each district. Whenever you have multiple observations that share something in common (share the same district, group, person), this is an indication that you probably have nested data!]


---
# Understanding clustered data

Let's look at the average math achievement score (`achievement`) across all grades for each Oregon district.


--
&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-2-1.png" width="576" style="display: block; margin: auto;" /&gt;


--
&lt;span style = "color:green"&gt; What is the relationship between proportion of ELL students and math achievement in Oregon districts? &lt;/span&gt;


---
# % ELL and achievement


--
We might consider averaging all 4 grades' math achievement scores in each district and fit a simple linear regression for the association between % ELL and math achievement:


--
&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-3-1.png" width="576" style="display: block; margin: auto;" /&gt;


--
But do we have more information if we didn't average the outcome over the 4 grades?

---
# Achievement for all grades

&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-4-1.png" style="display: block; margin: auto;" /&gt;

---
# Achievement for each grade

&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-5-1.png" style="display: block; margin: auto;" /&gt;


--
If we fit a model for each grade, what could differ about the regression lines for each grade?


---
# Relationship by grade

Fitting a simple linear regression model for each grade (i.e., 4 separate models):


--
&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-6-1.png" width="576" style="display: block; margin: auto;" /&gt;


--
Now that you see regression lines for each grade, what model parameters (intercepts, slopes) did end up differing for each grade?

---
# Intraclass correlation coefficient

We can estimate the differences we've been discussing using the &lt;span style = "color:green"&gt; intraclass correlation coefficient (ICC) &lt;/span&gt;. The ICC gives us an estimate of how much of the variability in our outcome is simply because of differences in the outcome between groups (in our example, grades). 


--
The ICC ranges from 0 to 1. The larger the ICC, the greater the proportion of variability in the outcome that is due to group differences. The ICC is one tool we can use to gauge whether clustering is important enough to warrant multilevel modeling.


--
&lt;span style = "color:green"&gt; The ICC for the math achievement outcome in our data is 0.645 or 64.5%. &lt;/span&gt; How would you interpret this? 


--
- 64.5% of the variation in the math achievement outcome is attributable to differences in achievement between grades. 


--
- Because the ICC is telling us that more than two-thirds of the variability in the outcome is because of grade (and has nothing to do with ELL proportion), we know that our findings could mask important differences in grade-level achievement.


---
# Simple linear regression


```r
m1 &lt;- lm(achievement ~ percent_ell, data = seda)
coef(m1) # Extracting intercept and %ELL coefficient
```

```
#&gt; (Intercept) percent_ell 
#&gt;    4.504827   -6.466889
```


--
This is called a &lt;span style = "color:green"&gt; fixed-effect model. &lt;/span&gt; We're assuming that grades are sufficiently similar that we can average the slopes and intercepts for each grade, and this will give us an accurate enough picture of the relationship of interest. 


--
Another way of saying this is each grade's slope and intercept are set - "fixed" - to be the average slope and intercept across grades.


---
# Simple linear regression

When thinking about whether a fixed-effect approach makes sense, we can apply the same reasoning we use when thinking about any average. 


--
Any mean is a single value (say, 31.5) that represents a set of values:


--
- If that set is close to the average (say, 29 and 34), then the single value of 31.5 is probably a good representation of the underlying values (i.e., it's not very different from 29 or 34). 


--
- But the same mean of 31.5 could represent the values of 0 and 63.


--
0-63 is the range of the Beck Depression Index (BDI): Does a mean of 31.5 convey that one person has no depression symptoms (0) and a second person has severe depression (63)?


---
# Mixed-effects model

Instead of the simple linear regression (fixed-effect model), we can fit a mixed-effects model that allows intercepts, or both intercepts and slopes, to vary across grades. 


--
In other words, this approach allows us to examine the underlying values of the intercepts and/or slopes that are contributing to the fixed-effect model estimates (the average of each grade's intercept and slope). 


--
- Another term for this is *disaggregating*, in the same sense as we used when talking about aggregation bias. We're potentially reducing our risk of aggregation bias by disaggregating results by grade. 


--
For now, let's look at what happens if we let the intercept (the average math achievement level at 0% ELL) vary by grade. This is called a &lt;span style = "color:green"&gt; random-intercepts model &lt;/span&gt; because the intercept is allowed to vary for each grade. 


---
# Random-intercepts model

For mixed-effects models, we'll use the `lmer()` function from the base R package *lme4*, which uses a function and formula style similar to the models we've been fitting:

--

```r
m2 &lt;- lmer(achievement ~ percent_ell + (1 | grade), data = seda)
```


--
The only difference from the usual linear regression specification is the element in parentheses. This is the "random effect" part of the model, or what we want to allow to differ across groups/clusters. 


--
- What is after the `|` is the variable that indicates the group/cluster. What is before the `|` is what we're interested in allowing to vary for each group. 


--
- Like the basic regression model where 1 is used to fit a model that estimates only the intercept, here the `(1 | grade)` means "only the intercept (1) can vary by grade."


---
# Random-intercepts model


```r
coef(m2)$grade # Specify the grouping variable
```

```
#&gt;         (Intercept) percent_ell
#&gt; Grade 3    2.856961   -6.466889
#&gt; Grade 4    3.913716   -6.466889
#&gt; Grade 5    5.065668   -6.466889
#&gt; Grade 6    6.182964   -6.466889
```


--
What do you notice is different for each grade?



---
# ICC and variability explained

In practice, before fitting a mixed-effects model, we'd fit the equivalent of the null model we're used to and use it to calculate the ICC. 


--

```r
m0 &lt;- lmer(achievement ~ 1 + (1 | grade), data = seda)
performance::icc(m0)
```

```
#&gt; # Intraclass Correlation Coefficient
#&gt; 
#&gt;     Adjusted ICC: 0.645
#&gt;   Unadjusted ICC: 0.645
```


--
There's a relationship between the ICC and variability explained, or `\(R^2\)`:


--
.pull-left[

```r
performance::r2_nakagawa(m0)
```

```
#&gt; # R2 for Mixed Models
#&gt; 
#&gt;   Conditional R2: 0.645
#&gt;      Marginal R2: 0.000
```
]


--
.pull-right[
In essence, the mixed-effect model is resetting our baseline of "explainable" variation from all of the variation in achievement (100%) to only the portion that is not attributable to differences in achievement by grade (100% - 65% = **35%**). 
]

---
# Adding random slopes

So far we've considered one intercept and slope for all grades or examining individual intercepts for each grade.


--
It's fairly clear from the earlier plot that the random-intercepts model is probably sufficient for our data. But let's illustrate what happens if we examine intercepts *and* slopes for each grade (random-slopes-and-intercepts model).


--
&lt;span style = "color:green"&gt; Random-slopes-and-intercepts model: &lt;/span&gt;


```r
m3 &lt;- lmer(achievement ~ percent_ell + (percent_ell|grade), data = seda)
coef(m3)$grade
```

```
#&gt;         (Intercept) percent_ell
#&gt; Grade 3    2.826638   -6.120839
#&gt; Grade 4    3.904292   -6.343056
#&gt; Grade 5    5.075495   -6.584562
#&gt; Grade 6    6.212885   -6.819096
```


--
.small[Note that we can look at slopes for each grade with only one intercept across grades (random-slopes model), but in practice we wouldn't typically test this model. If the random-intercepts model is better fitting than the fixed-effect model, the next logical step in model fitting is to add random slopes to the random-intercepts model (i.e., the random-slopes-and-intercepts model).]

---
# Fixed effect vs random effects

&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-13-1.png" width="576" style="display: block; margin: auto;" /&gt;


---
# Bringing it together

--
.pull-left[
The &lt;span style = "color:green"&gt; random-slopes-and-intercepts model &lt;/span&gt; gives us the slope and intercept for each cluster:


```r
coef(m3)$grade
```

```
#&gt;         (Intercept) percent_ell
#&gt; Grade 3    2.826638   -6.120839
#&gt; Grade 4    3.904292   -6.343056
#&gt; Grade 5    5.075495   -6.584562
#&gt; Grade 6    6.212885   -6.819096
```
]

--
.pull-right[
The &lt;span style = "color:green"&gt; fixed-effect model &lt;/span&gt; gives us the average (or aggregation) of the different intercepts and slopes across clusters:
 

```r
coef(m1)
```

```
#&gt; (Intercept) percent_ell 
#&gt;    4.504827   -6.466889
```
]


--
.pull-left[
In other words, the fixed-effect results are the average of the intercepts and slopes for each grade:
]


--
.pull-right[

```
#&gt;      (Intercept) percent_ell
#&gt; [1,]    4.504827   -6.466889
```
]


--
So, back to averages: Does the average of the slope and the intercept give a good enough representation of the slopes and intercepts across grades? If not, which one do you think we need to examine by grade?


---
# Model comparison

We can use many of the same tools we've already used to compare models, including deviance tests and AIC. We'll also use RMSE (root mean square error), which is the average difference between values predicted by the model and the actual values in our data (so, lower RMSE = better fitting).


--

```r
performance::test_likelihoodratio(m1, m2) %&gt;% 
  print_md() # Only for slides
```



|Name |           Model| df| df_diff|   Chi2|        p|
|:----|---------------:|--:|-------:|------:|--------:|
|m1   |              lm|  3|        |       |         |
|m2   | lmerModLmerTest|  4|       1| 159.56| 1.41e-36|


--

```r
performance::test_likelihoodratio(m2, m3) %&gt;% print_md()
```



|Name |          Model | df| df_diff| Chi2|    p|
|:----|:---------------|--:|-------:|----:|----:|
|m2   |lmerModLmerTest |  4|        |     |     |
|m3   |lmerModLmerTest |  6|       2| 0.08| 0.96|


---
# Model comparison


```r
performance::compare_performance(m1, m2, m3, metrics = "common") %&gt;% 
  print_md()
```



Table: Comparison of Model Performance Indices

|Name |           Model | AIC (weights) |    BIC (weights) | RMSE | R2 (cond.) | R2 (marg.) |  ICC |   R2 | R2 (adj.) |
|:----|:---------------:|:-------------:|:----------------:|:----:|:----------:|:----------:|:----:|:----:|:---------:|
|m1   |              lm | 663.7 (&lt;.001) |    673.2 (&lt;.001) | 1.57 |            |            |      | 0.09 |      0.08 |
|m2   | lmerModLmerTest |  506.2 (0.88) |     518.8 (0.99) | 0.94 |       0.72 |       0.07 | 0.70 |      |           |
|m3   | lmerModLmerTest |  510.1 (0.12) | 529.1 (6.00e-03) | 0.94 |       0.72 |       0.07 | 0.70 |      |           |


--
So, the random-intercepts model is better fitting than the fixed-effect model (the simple linear regression), but the random-slopes-and-intercepts model is not any better fitting than the random-intercepts model.


---
# Back to variability explained


--
.pull-left[

&lt;span style = "color:green"&gt; Our understanding from the fixed-effect model: &lt;/span&gt;All variation in math achievement could be explained, but %ELL explained very little of it (marginal `\(R^2\)` from previous slide, or `\(R^2\)` from simple linear regression). We might have concluded that %ELL was not an important predictor of math achievement. 
]


.pull-right[
&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-20-1.png" width="576" style="display: block; margin: auto;" /&gt;
]


--
.pull-left[
&lt;span style = "color:green"&gt; Our understanding from the random-intercepts model: &lt;/span&gt;Only one-third of variation in math achievement could be explained after accounting for differences in achievement by grade (65%). %ELL and grade differences explain 72% of variability in math achievement (conditional `\(R^2\)`). This could lead to a very different conclusion compared with the fixed-effect model. 
]


.pull-right[
&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-21-1.png" width="576" style="display: block; margin: auto;" /&gt;
]


---
# Covariates, interactions, etc

Just as with the fixed-effect models we've used up to now, we can improve mixed-effects model fit by adding covariates. 


--
However, as we've seen, with mixed-effects models we can also influence model fit by adding random intercepts or random intercepts and slopes. 


--
For this reason, in mixed-effects models it is especially important to use theory and existing research to select covariates and moderators of interest ahead of time.


--
- It also means that studies that will generate nested data (and analyses of existing data) should be carefully planned and informed by available theory and research. 


--
Finally, we must approach fit testing carefully, to be sure we are isolating and testing each change we've made (if we test the addition of a covariate and a random effect together, we don't know which improved model fit).

---
# Popular

The dataset `popular` includes data on students' levels of extraversion and popularity, students' sex, and teacher experience level (a classroom-level variable). 1,000 students are nested in 100 classrooms. 


--

```r
head(popular) %&gt;% print_md()
```



|pupil | class| extrav|   sex | texp| popular| popteach|
|:-----|-----:|------:|:------|----:|-------:|--------:|
|1     |     1|      5|Female |   24|    6.30|        6|
|2     |     1|      7|  Male |   24|    4.90|        5|
|3     |     1|      4|Female |   24|    5.30|        6|
|4     |     1|      3|Female |   24|    4.70|        5|
|5     |     1|      5|Female |   24|    6.00|        6|
|6     |     1|      4|  Male |   24|    4.70|        5|


--
How can you tell the difference between student-level variables and classroom-level variables?



---
# Including covariates and cross-level interaction

**We're interested in whether students who are more extroverted are, in general, more popular than students who are more introverted.**


--
Imagine existing studies have sometimes, but not always, found that this relationship differs by (or, is moderated by) student sex. Because this is not a consistent finding, we'll plan to control for sex but not examine a moderation relationship (i.e., interaction). 


--
Finally, we have an exploratory question about whether teacher experience is a moderator of the association between extraversion and popularity.


--
- Perhaps more experienced teachers assert more control of the classroom, resulting in less extraversion/attention-seeking from students (so, student popularity in those classrooms may be driven by other factors).


---
# Model fitting steps

--
1) Null model including a random effect for classroom, to calculate the ICC:


```r
pop_m0 &lt;- lmer(popular ~ 1 + (1 | class), data = popular)
```

--
2) Random-intercepts model including the student-level independent variable (extraversion) and control variable (sex):


```r
pop_m1 &lt;- lmer(popular ~ extrav + sex + (1 | class), 
               REML = FALSE, data = popular)
```


--
3) Random-intercepts-and-slopes model to test whether random slopes are needed for student-level predictors:


```r
pop_m2 &lt;- lmer(popular ~ extrav + sex + (1 + extrav + sex | class), 
               REML = FALSE, data = popular)
```


--
4) Test the cross-level interaction using the best-fitting model, then run diagnostics.


---
# Initial look at the data

&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-26-1.png" width="576" style="display: block; margin: auto;" /&gt;


---
# Model fitting 


--
*Load the `lmertest` package, which includes supplementary tools for `lmer` models, before fitting any models.*


--

```r
performance::icc(pop_m0)
```

```
#&gt; # Intraclass Correlation Coefficient
#&gt; 
#&gt;     Adjusted ICC: 0.365
#&gt;   Unadjusted ICC: 0.365
```


--
A substantial amount of variability in student popularity (37%) is attributable to differences in popularity across classrooms, so it will be important to account for this going forward. 


---
# Model fitting 


```r
performance::compare_performance(pop_m1, pop_m2, metrics = "common") %&gt;% 
  print_md()
```



Table: Comparison of Model Performance Indices

|Name   |           Model |  AIC (weights) |  BIC (weights) | R2 (cond.) | R2 (marg.) |  ICC | RMSE |
|:------|:---------------:|:--------------:|:--------------:|:----------:|:----------:|:----:|:----:|
|pop_m1 | lmerModLmerTest | 4944.0 (&lt;.001) | 4972.0 (&lt;.001) |       0.70 |       0.39 | 0.51 | 0.75 |
|pop_m2 | lmerModLmerTest | 4876.6 (&gt;.999) | 4932.6 (&gt;.999) |       0.73 |       0.38 | 0.56 | 0.72 |


--
Overall, the model with random intercepts and slopes is better fitting (AIC, RMSE) and somewhat more explanatory (conditional `\(R^2\)`). However, we added 2 random slopes, so we want to see if it's necessary to keep both of these or just one. 



---
# Model fitting 

First, we can see in the model summary that the variance for sex is very small, meaning the slope for sex doesn't vary much across classroom. 



```r
print(VarCorr(pop_m2), comp = "Variance")
```

```
#&gt;  Groups   Name        Variance  Cov          
#&gt;  class    (Intercept) 2.5032818              
#&gt;           extrav      0.0292503 -0.256       
#&gt;           sexMale     0.0052834  0.034  0.000
#&gt;  Residual             0.5526259
```


--
This is a clue that sex may not need to be retained as a random slope (we're also getting a "failed to converge" warning at the end of the summary, which can be because of low variance of a random effect).


---
# Model fitting 

We can test the significance of the difference in fit between models with and without each of the random slopes in a similar way to the likelihood ratio test we've used before. We can test models that differ only in random effects by using the `ranova()` function from *lmertest*.


```r
lmerTest::ranova(pop_m2, reduce.terms = TRUE)
```

```
#&gt; ANOVA-like table for random-effects: Single term deletions
#&gt; 
#&gt; Model:
#&gt; popular ~ extrav + sex + (1 + extrav + sex | class)
#&gt;                                      npar  logLik    AIC    LRT Df Pr(&gt;Chisq)
#&gt; &lt;none&gt;                                 10 -2428.3 4876.6                     
#&gt; extrav in (1 + extrav + sex | class)    7 -2465.1 4944.1 73.505  3  7.578e-16
#&gt; sex in (1 + extrav + sex | class)       7 -2429.6 4873.1  2.493  3     0.4766
#&gt;                                         
#&gt; &lt;none&gt;                                  
#&gt; extrav in (1 + extrav + sex | class) ***
#&gt; sex in (1 + extrav + sex | class)       
#&gt; ---
#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```

---
# Model fitting 

We saw that the random slope for sex is nonsignificant, so our final model before testing the cross-level interaction should retain the random slope for extraversion and drop the random slope for sex. We can now add the interaction to that model:


```r
pop_m3 &lt;- lmer(popular ~ extrav + sex + 
                 (1 + extrav | class), REML = FALSE, data = popular)
pop_m3_int &lt;- lmer(popular ~ extrav + sex + texp*extrav + 
                     (1 + extrav | class), REML = FALSE, data = popular)
coef(summary(pop_m3_int)) # Assess interaction significance
```

```
#&gt;                Estimate  Std. Error         df     t value      Pr(&gt;|t|)
#&gt; (Intercept)  0.03360313 0.271443778  115.79766   0.1237941  9.016929e-01
#&gt; extrav       0.80312216 0.039539541   72.36269  20.3118736  1.296761e-31
#&gt; sexMale     -1.24060636 0.036202989 1944.99254 -34.2680640 9.398631e-202
#&gt; texp         0.22602925 0.016616024  100.31563  13.6030887  1.656191e-24
#&gt; extrav:texp -0.02469800 0.002518135   72.28513  -9.8080547  6.392379e-15
```


---
# Model fitting 


```r
performance::compare_performance(pop_m3, pop_m3_int, metrics = "common") %&gt;% 
  print_md()
```



Table: Comparison of Model Performance Indices

|Name       |           Model |  AIC (weights) |  BIC (weights) | R2 (cond.) | R2 (marg.) |  ICC | RMSE |
|:----------|:---------------:|:--------------:|:--------------:|:----------:|:----------:|:----:|:----:|
|pop_m3     | lmerModLmerTest | 4873.1 (&lt;.001) | 4912.3 (&lt;.001) |       0.73 |       0.38 | 0.56 | 0.72 |
|pop_m3_int | lmerModLmerTest | 4765.6 (&gt;.999) | 4816.0 (&gt;.999) |       0.71 |       0.55 | 0.34 | 0.72 |

--
So, our interaction is significant and the model with the interaction seems better fitting. But before we interpret it, we should run diagnostics on the final model. Note that we don't need to standardize residuals because our outcome is continuous. 

&lt;span style = "color:green"&gt; Before diagnostics and interpretation of a final model, rerun the model without `REML = FALSE`. &lt;/span&gt;


---
# Diagnostics


```r
pop_m3_int_fin &lt;- lmer(popular ~ extrav + sex + texp*extrav + 
                         (1 + extrav | class), data = popular)
check_model(pop_m3_int_fin, check = c("linearity", "outliers", 
                                      "vif", "qq"))
```

&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-33-1.png" width="576" style="display: block; margin: auto;" /&gt;

---
# Interpreting the interaction

Overall, there aren't major concerns from model diagnostics. To interpret the interaction, we'll take a similar approach as we have for other interactions using predicted values, but here we'll use the `ggpredict` function and set *type* to `re` for random effects. 

Teacher experience is a continuous variable ranging from 2 to 25 years, so we'll also set a few levels of experience: new teacher (2 years), moderately experienced (10 years), highly experienced (25 years). 


--

```r
# using the ggeffects package
library(ggeffects)
pop_m3_int_pred &lt;- ggpredict(pop_m3_int_fin,
                             type = "re",
                             terms = c("extrav", "texp [2, 10, 25]"))
```


---
# Interpreting the interaction


```r
pop_m3_int_pred
```

```
#&gt; # Predicted values of popularity sociometric score
#&gt; 
#&gt; # texp = 2
#&gt; 
#&gt; extrav | Predicted |        95% CI
#&gt; ----------------------------------
#&gt;      1 |      1.24 | [-0.28, 2.75]
#&gt;      2 |      1.99 | [ 0.49, 3.49]
#&gt;      4 |      3.50 | [ 2.02, 4.98]
#&gt;      6 |      5.01 | [ 3.53, 6.49]
#&gt;      7 |      5.76 | [ 4.28, 7.24]
#&gt;     10 |      8.02 | [ 6.52, 9.53]
#&gt; 
#&gt; # texp = 10
#&gt; 
#&gt; extrav | Predicted |       95% CI
#&gt; ---------------------------------
#&gt;      1 |      2.85 | [1.37, 4.33]
#&gt;      2 |      3.41 | [1.93, 4.88]
#&gt;      4 |      4.52 | [3.05, 5.98]
#&gt;      6 |      5.63 | [4.17, 7.10]
#&gt;      7 |      6.19 | [4.72, 7.65]
#&gt;     10 |      7.86 | [6.38, 9.33]
#&gt; 
#&gt; # texp = 25
#&gt; 
#&gt; extrav | Predicted |       95% CI
#&gt; ---------------------------------
#&gt;      1 |      5.87 | [4.37, 7.37]
#&gt;      2 |      6.06 | [4.57, 7.54]
#&gt;      4 |      6.43 | [4.95, 7.90]
#&gt;      6 |      6.80 | [5.32, 8.27]
#&gt;      7 |      6.98 | [5.51, 8.46]
#&gt;     10 |      7.54 | [6.03, 9.05]
#&gt; 
#&gt; Adjusted for:
#&gt; *   sex = Female
#&gt; * class = 0 (population-level)
```

---
# Interpreting the interaction


```r
plot(pop_m3_int_pred, ci = FALSE)
```

&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-36-1.png" width="576" style="display: block; margin: auto;" /&gt;

---
# Longitudinal data

Analyzing longitudinal data with mixed models is approached in generally the same way as analyzing other nested data. 


--
With longitudinal (or repeated-measures) data, the main form of clustering is by participant: repeated measures taken of the outcome for each participant (e.g. at baseline, immediately after an intervention, and 1 year after the intervention).


--
This said, we can still have the same forms of clustering/nesting that we've talked about already:


--
- Multiple assessments of students in different classrooms, schools, etc.


--
- Multiple assessments of patients at different clinics, hospitals, etc. 


--
We can model these different kinds of dependencies using mixed models, and because we are still working in the GLM framework, we can also analyze different types of outcomes. 


---
# Respire data

The `respire` dataset is from a randomized controlled trial (RCT) of a drug for the treatment of a respiratory illness. The outcome was whether the patient developed the illness, and was measured in 111 participants across 2 medical centers. The outcome was measured 4 times for each participant: baseline (pretreatment) and at 3 follow-up visits. 

* `outcome`: developed respiratory illness (Yes or No)
* `visit`: measurement point (Baseline, F1, F2, F3)
* `assignment`: group assignment (placebo - P or active - A)
* `center`: treatment center (1/2)
* `id`: patient ID
* `sex`: patient sex (M or F)
* `age`: patient age (range 11-68 years)


---
# Respire data


```r
head(respire, n = 10) %&gt;% print_md()
```



|center | id| sex| age|   visit | outcome|  age.c| assignment|
|:------|--:|---:|---:|:--------|-------:|------:|----------:|
|1      |  1|   M|  46|Baseline |      No|  12.72|  Treatment|
|1      |  1|   M|  46|      F1 |      No|  12.72|  Treatment|
|1      |  1|   M|  46|      F2 |      No|  12.72|  Treatment|
|1      |  1|   M|  46|      F3 |      No|  12.72|  Treatment|
|1      |  2|   M|  28|Baseline |      No|  -5.28|  Treatment|
|1      |  2|   M|  28|      F1 |      No|  -5.28|  Treatment|
|1      |  2|   M|  28|      F2 |      No|  -5.28|  Treatment|
|1      |  2|   M|  28|      F3 |      No|  -5.28|  Treatment|
|1      |  3|   M|  23|Baseline |     Yes| -10.28|    Placebo|
|1      |  3|   M|  23|      F1 |     Yes| -10.28|    Placebo|

---
# Longitudinal data

When analyzing longitudinal data, an additional consideration is how the outcome changes over time. This is especially important when we are comparing outcomes across groups, such as a group that received an intervention/treatment and a group that did not (control group).


--
If we just look at the main effect of *treatment group assignment* (whether someone received the treatment or not), then we are combining the outcome values across measurement points.


--
- It's common to see a large treatment effect right after the intervention, and then the effect gets smaller over time. If we combine large and small outcome estimates together, we get a smaller overall estimate. 


--
If we just look at the main effect of *time* (e.g., follow-up visit or assessment number), then we are ignoring group assignment. This doesn't give us insight into whether the treatment is effective.


--
What do you think is the solution?


--
- `treatment x time` interaction


---
# Model fitting

--
1) Null model including a random effect for participant, to calculate the ICC:


```r
respire_m0 &lt;- glmer(outcome ~ 1 + (1 | id), family = binomial, 
                    data = respire)
performance::icc(respire_m0)
```

```
#&gt; # Intraclass Correlation Coefficient
#&gt; 
#&gt;     Adjusted ICC: 0.317
#&gt;   Unadjusted ICC: 0.317
```

--
2) Random-intercepts model including the `treatment x time` interaction and control variables (sex and age). For random-effects, we generally want at least 5 units. Here, we only have 2 centers, so we'll instead include a fixed effect for center (i.e., a control variable).


```r
respire_m1 &lt;- glmer(outcome ~ assignment*visit + sex + age.c + center + 
                      (1 | id), family = binomial, 
                    control = glmerControl(optimizer = "bobyqa", 
                                           optCtrl = list(maxfun = 2e5)),
                    data = respire)
```

---
# Model fitting 

3) Random-intercepts-and-slopes model to test whether random slopes are needed for time:


```r
respire_m2 &lt;- glmer(outcome ~ assignment*visit + sex + age.c + center + 
                      (visit | id), family = binomial, 
                    control = glmerControl(optimizer = "bobyqa", 
                                           optCtrl = list(maxfun = 2e5)),
                    data = respire)
```

--

```r
anova(respire_m1, respire_m2)
```

```
#&gt; Data: respire
#&gt; Models:
#&gt; respire_m1: outcome ~ assignment * visit + sex + age.c + center + (1 | id)
#&gt; respire_m2: outcome ~ assignment * visit + sex + age.c + center + (visit | id)
#&gt;            npar    AIC    BIC  logLik deviance  Chisq Df Pr(&gt;Chisq)
#&gt; respire_m1   12 522.48 571.63 -249.24   498.48                     
#&gt; respire_m2   21 539.74 625.75 -248.87   497.74 0.7419  9     0.9998
```

---
# Model fitting 


```r
performance::compare_performance(respire_m1, respire_m2, metrics = "common") %&gt;% 
  print_md()
```

```
#&gt; Random effect variances not available. Returned R2 does not account for random effects.
```



Table: Comparison of Model Performance Indices

|Name       |    Model | AIC (weights) | BIC (weights) | R2 (cond.) | R2 (marg.) | RMSE |  ICC |
|:----------|:--------:|:-------------:|:-------------:|:----------:|:----------:|:----:|:----:|
|respire_m1 | glmerMod | 522.5 (&gt;.999) | 571.6 (&gt;.999) |       0.50 |       0.19 | 0.37 | 0.38 |
|respire_m2 | glmerMod | 539.7 (&lt;.001) | 625.8 (&lt;.001) |            |       0.28 | 0.37 |      |


---
# Model diagnostics 


```r
respire_m1_residuals &lt;- simulateResiduals(respire_m1, n = 1000) 
plot(respire_m1_residuals)
```

&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-43-1.png" width="576" style="display: block; margin: auto;" /&gt;

---
# Model diagnostics 


```r
check_model(respire_m1, check = "vif")
```

&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-44-1.png" width="576" style="display: block; margin: auto;" /&gt;

---
# Interpretation


```r
# using the ggeffects package
respire_m1_probs &lt;- ggeffect(respire_m1,
                             type = "re",
                             terms = c("visit", "assignment"))
respire_m1_probs
```

```
#&gt; # Predicted probabilities of outcome
#&gt; 
#&gt; # assignment = Placebo
#&gt; 
#&gt; visit    | Predicted |       95% CI
#&gt; -----------------------------------
#&gt; Baseline |      0.76 | [0.58, 0.88]
#&gt; F1       |      0.78 | [0.60, 0.89]
#&gt; F2       |      0.80 | [0.63, 0.90]
#&gt; F3       |      0.66 | [0.46, 0.81]
#&gt; 
#&gt; # assignment = Treatment
#&gt; 
#&gt; visit    | Predicted |       95% CI
#&gt; -----------------------------------
#&gt; Baseline |      0.49 | [0.31, 0.67]
#&gt; F1       |      0.34 | [0.19, 0.53]
#&gt; F2       |      0.44 | [0.27, 0.63]
#&gt; F3       |      0.41 | [0.25, 0.60]
```

---
# Interpretation


```r
plot(respire_m1_probs)
```

&lt;img src="EDUC645_nested_data_Sp23_files/figure-html/unnamed-chunk-46-1.png" width="576" style="display: block; margin: auto;" /&gt;

---
# A final note about cluster-robust SEs

Cluster-robust (or sandwich) standard errors are sometimes used instead of mixed-effects models (that is, instead of explicitly incorporating the nested structure of the data into the analysis). Although they're more straightforward to implement, these SEs have several limitations:


--
- They don't give us insight into whether the *relationship* between the predictor(s) and outcome differs across clusters.


--
- They don't address the issue of misinterpreting the variability explained by our model, meaning they shouldn't be used unless the null ICC is very small (e.g., less than 5%).


--
- They're only appropriate for simple forms of clustering and when sampling or randomization was conducted at the same level of the cluster. 


--
For all of these reasons, it's generally better to use a model that is more informative about, and better accounts for, the nested structure of your data (and you can still use cluster-robust SEs!). 





    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
